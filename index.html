<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Kadastrale metingen visualisatie</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
    }
    #left, #right {
      padding: 10px;
      height: 100vh;
    }
    #left {
      width: 50%;
      border-right: 1px solid #ccc;
    }
    #right {
      width: 50%;
    }
    textarea {
      width: 100%;
      height: calc(100vh - 20px);
      font-family: monospace;
      font-size: 14px;
    }
    svg {
      width: 100%;
      height: 100%;
      border: 1px solid #ccc;
      background: #fafafa;
    }
    .point {
      fill: #0074D9;
      stroke: #003366;
      stroke-width: 1;
    }
    .point-label {
      font-size: 12px;
      fill: #000;
    }
    .distance-label {
      font-size: 11px;
      fill: #555;
    }
    .segment {
      stroke-width: 2;
    }
    .segment-default {
      stroke: #111;
    }
    .segment-gebouw {
      stroke: #d00;
    }
  </style>
</head>
<body>
  <div id="left">
    <textarea id="input"
placeholder="Voorbeeld:
P1 -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
P1 -- P5 [0.4] -gebouw- P6 [10.55] -- P7 [11.8]
P7 -- P4 [25]"></textarea>
  </div>
  <div id="right">
    <svg id="viewBox" viewBox="0 0 100 100"></svg>
  </div>

  <script>
    const textarea = document.getElementById('input');
    const svg = document.getElementById('viewBox');

    textarea.addEventListener('input', () => {
      const text = textarea.value;
      const {nodes, segments, chains} = parseInput(text);
      layoutChainsStrict(nodes, segments, chains);
      render(nodes, segments);
    });

    function parseInput(text) {
      const nodeMap = new Map();
      const segments = [];
      const chains = [];

      function getNode(id) {
        const key = id.toUpperCase();
        if (!nodeMap.has(key)) {
          nodeMap.set(key, {
            id: key,
            x: null,
            y: null,
            fixed: false,
            chainId: null,
            chainAngle: 0,
            tempPos: 0
          });
        }
        return nodeMap.get(key);
      }

      const lines = text.split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length > 0);

      // Parse individuele chains per regel
      lines.forEach((line, lineIndex) => {
        const rawParts = line.split(/(-gebouw-)|(--)/i).filter(p => p && p.trim() !== '');
        const tokens = [];
        for (const part of rawParts) {
          const trimmed = part.trim();
          if (/^-?gebouw-?$/i.test(trimmed)) {
            tokens.push({type: 'connector', value: 'gebouw'});
          } else if (trimmed === '--') {
            tokens.push({type: 'connector', value: 'default'});
          } else {
            tokens.push({type: 'node', value: trimmed});
          }
        }

        const lineNodes = [];
        const lineSegs = [];
        for (let i = 0; i < tokens.length - 2; i += 2) {
          const tA = tokens[i];
          const tC = tokens[i + 1];
          const tB = tokens[i + 2];
          if (tA.type !== 'node' || tC.type !== 'connector' || tB.type !== 'node') continue;

          const nodeA = parseNodeToken(tA.value, getNode);
          const nodeB = parseNodeToken(tB.value, getNode);
          nodeA.chainId = lineIndex;
          nodeB.chainId = lineIndex;
          lineNodes.push(nodeA, nodeB);

          const distMatch = tB.value.match(/\[([^\]]+)\]/);
          let dist = null;
          if (distMatch) {
            const d = parseFloat(distMatch[1].trim().replace(',', '.'));
            if (!isNaN(d)) dist = d;
          }

          const segType = tC.value === 'gebouw' ? 'gebouw' : 'default';
          lineSegs.push({from: nodeA, to: nodeB, dist, type: segType});
          segments.push({from: nodeA, to: nodeB, dist, type: segType});
        }
        if (lineNodes.length > 0) {
          chains.push({nodes: [...new Set(lineNodes)], segments: lineSegs, lineIndex});
        }
      });

      const nodes = Array.from(nodeMap.values());
      
      // MERGE chains die overlappen via gedeelde nodes
      const mergedChains = [];
      const visited = new Set();
      chains.forEach((chain, i) => {
        if (visited.has(i)) return;
        const superChain = {
          nodes: [...chain.nodes],
          segments: [...chain.segments],
          subchains: [chain]
        };
        visited.add(i);
        
        // Recursief alle overlappende chains toevoegen
        function expand(currentChain) {
          chains.forEach((other, j) => {
            if (visited.has(j)) return;
            const overlap = currentChain.nodes.some(n => other.nodes.includes(n));
            if (overlap) {
              visited.add(j);
              superChain.nodes.push(...other.nodes);
              superChain.segments.push(...other.segments);
              superChain.subchains.push(other);
              expand(other);
            }
          });
        }
        expand(chain);
        
        superChain.nodes = [...new Set(superChain.nodes)];
        mergedChains.push(superChain);
      });
      
      return {nodes, segments, chains: mergedChains};
    }

    function parseNodeToken(raw, getNode) {
      const idMatch = raw.match(/^[^\s\(\[]+/);
      const id = idMatch ? idMatch[0] : raw.trim();
      const node = getNode(id);

      const coordMatch = raw.match(/\(([^\)]+)\)/);
      if (coordMatch) {
        const nums = coordMatch[1].split(',').map(s => parseFloat(s.trim().replace(',', '.')));
        if (nums.length >= 2 && !isNaN(nums[0]) && !isNaN(nums[1])) {
          node.x = nums[0];
          node.y = nums[1];
          node.fixed = true;
        }
      }
      return node;
    }

    function layoutChainsStrict(nodes, segments, chains) {
      if (nodes.length === 0) return;
      const idealScale = 5;

      // Stap 1: Per subchain PERFECT rechte lijn maken
      chains.forEach((superChain, superIndex) => {
        superChain.subchains.forEach((chain) => {
          if (chain.nodes.length === 0) return;

          // Expliciete lineaire volgorde
          let order = [];
          if (chain.segments.length > 0) {
            let current = chain.segments[0].from;
            order = [current];
            for (const seg of chain.segments) {
              const nextNode = seg.from === current ? seg.to : seg.from;
              if (!order.includes(nextNode)) {
                order.push(nextNode);
                current = nextNode;
              }
            }
          } else {
            order = chain.nodes;
          }
          
          chain.order = order;

          // Cumulatieve afstanden (exact!)
          let cum = 0;
          order.forEach((node, i) => {
            if (i === 0) {
              node.tempPos = 0;
              cum = 0;
            } else {
              const prev = order[i - 1];
              const seg = chain.segments.find(s =>
                (s.from === prev && s.to === node) || (s.to === prev && s.from === node));
              cum += seg?.dist || 1;
              node.tempPos = cum;
            }
          });

          // Initiële plaatsing met verschillende oriëntatie
          const baseAngle = superIndex * 0.8 + chain.lineIndex * 0.2;
          order.forEach(node => {
            if (node.fixed) return;
            const t = node.tempPos * idealScale;
            node.x = t * Math.cos(baseAngle);
            node.y = t * Math.sin(baseAngle);
            node.chainAngle = baseAngle;
          });
        });
      });

      // Stap 2: Globale optimalisatie per superchain
      const iterations = 150;
      for (let it = 0; it < iterations; it++) {
        chains.forEach((superChain) => {
          // Krachten berekenen tussen subchains
          const chainForces = new Map();
          superChain.subchains.forEach(chain => chainForces.set(chain, {fx: 0, fy: 0}));

          // Repulsie tussen nodes van verschillende subchains
          for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
              const a = nodes[i];
              const b = nodes[j];
              if (a.chainId === b.chainId || a.x == null || b.x == null) continue;

              let dx = b.x - a.x;
              let dy = b.y - a.y;
              let dist2 = dx * dx + dy * dy + 0.1;
              let force = 80 / dist2;
              dx /= Math.sqrt(dist2);
              dy /= Math.sqrt(dist2);

              const chainA = superChain.subchains.find(c => c.lineIndex === a.chainId);
              const chainB = superChain.subchains.find(c => c.lineIndex === b.chainId);
              if (chainA) {
                const fa = chainForces.get(chainA);
                fa.fx += dx * force * 0.3;
                fa.fy += dy * force * 0.3;
              }
              if (chainB) {
                const fb = chainForces.get(chainB);
                fb.fx -= dx * force * 0.3;
                fb.fy -= dy * force * 0.3;
              }
            }
          }

          // Inter-subchain afstanden respecteren
          for (const seg of superChain.segments) {
            const a = seg.from;
            const b = seg.to;
            if (a.chainId === b.chainId || a.x == null || b.x == null) continue;

            const target = seg.dist ? seg.dist * idealScale : null;
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            let dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
            dx /= dist;
            dy /= dist;
            let desired = target || dist;
            let delta = dist - desired;
            let force = 0.8 * delta;

            const chainA = superChain.subchains.find(c => c.lineIndex === a.chainId);
            const chainB = superChain.subchains.find(c => c.lineIndex === b.chainId);
            if (chainA) {
              const fa = chainForces.get(chainA);
              fa.fx += dx * force;
              fa.fy += dy * force;
            }
            if (chainB) {
              const fb = chainForces.get(chainB);
              fb.fx -= dx * force;
              fb.fy -= dy * force;
            }
          }

          // Beweeg subchains als geheel
          superChain.subchains.forEach(chain => {
            if (!chain.order || chain.order.length === 0) return;
            
            const force = chainForces.get(chain);
            if (!force) return;

            // Center of mass
            let cx = 0, cy = 0, count = 0;
            chain.order.forEach(n => {
              if (n.x != null && !n.fixed) {
                cx += n.x; cy += n.y; count++;
              }
            });
            if (count === 0) return;
            cx /= count; cy /= count;

            const rotForce = Math.atan2(force.fy, force.fx) * 0.015;
            const newAngle = chain.order[0].chainAngle + rotForce;

            // Herplaats EXACT langs rechte lijn
            chain.order.forEach(node => {
              if (node.fixed) return;
              const t = node.tempPos * idealScale;
              node.x = cx + t * Math.cos(newAngle);
              node.y = cy + t * Math.sin(newAngle);
              node.chainAngle = newAngle;
            });
          });
        });
      }
    }

    function render(nodes, segments) {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      if (nodes.length === 0) return;

      const xs = nodes.map(n => n.x).filter(x => x != null);
      const ys = nodes.map(n => n.y).filter(y => y != null);
      let minX = Math.min(...xs), maxX = Math.max(...xs);
      let minY = Math.min(...ys), maxY = Math.max(...ys);
      
      if (xs.length === 0 || minX === maxX) { minX -= 10; maxX += 10; }
      if (ys.length === 0 || minY === maxY) { minY -= 10; maxY += 10; }
      
      const pad = 8;
      const width = maxX - minX;
      const height = maxY - minY;

      svg.setAttribute('viewBox',
        [minX - pad, minY - pad, width + 2 * pad, height + 2 * pad].join(' '));

      // Segmenten
      for (const seg of segments) {
        const a = seg.from, b = seg.to;
        if (a.x == null || b.x == null) continue;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        line.setAttribute('class', 'segment ' + 
          (seg.type === 'gebouw' ? 'segment-gebouw' : 'segment-default'));
        svg.appendChild(line);

        if (seg.dist != null) {
          const mx = (a.x + b.x) / 2;
          const my = (a.y + b.y) / 2;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', mx);
          text.setAttribute('y', my - 1);
          text.setAttribute('class', 'distance-label');
          text.textContent = seg.dist.toFixed(2);
          svg.appendChild(text);
        }
      }

      // Punten
      const maxDim = Math.max(width, height) || 20;
      const r = Math.max(2, 0.8 * maxDim / 50);
      for (const n of nodes) {
        if (n.x == null || n.y == null) continue;
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', n.x);
        circle.setAttribute('cy', n.y);
        circle.setAttribute('r', r);
        circle.setAttribute('class', 'point');
        svg.appendChild(circle);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', n.x + maxDim / 80);
        label.setAttribute('y', n.y - maxDim / 80);
        label.setAttribute('class', 'point-label');
        label.textContent = n.id;
        svg.appendChild(label);
      }
    }

    // Init met driehoek voorbeeld
    textarea.value = `P1 -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
P1 -- P5 [0.4] -gebouw- P6 [10.55] -- P7 [11.8]
P7 -- P4 [25]`;
    textarea.dispatchEvent(new Event('input'));
  </script>
</body>
</html>
