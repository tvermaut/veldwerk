<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Kadastrale metingen visualisatie</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
    }
    #left, #right {
      padding: 10px;
      height: 100vh;
    }
    #left {
      width: 50%;
      border-right: 1px solid #ccc;
    }
    #right {
      width: 50%;
    }
    textarea {
      width: 100%;
      height: calc(100vh - 20px);
      font-family: monospace;
      font-size: 14px;
    }
    svg {
      width: 100%;
      height: 100%;
      border: 1px solid #ccc;
      background: #fafafa;
    }
    .point {
      fill: #0074D9;
      stroke: #003366;
      stroke-width: 1;
    }
    .point-label {
      font-size: 12px;
      fill: #000;
    }
    .distance-label {
      font-size: 11px;
      fill: #555;
    }
    .segment {
      stroke-width: 2;
    }
    .segment-default {
      stroke: #111;
    }
    .segment-gebouw {
      stroke: #d00;
    }
  </style>
</head>
<body>
  <div id="left">
    <textarea id="input">P1 -- P2 [5.40]
P2 -- P3 [8.83] 
P3 -- P1 [10.00]</textarea>
  </div>
  <div id="right">
    <svg id="viewBox" viewBox="0 0 100 100"></svg>
  </div>

  <script>
    const textarea = document.getElementById('input');
    const svg = document.getElementById('viewBox');

    textarea.addEventListener('input', () => {
      const text = textarea.value;
      const {nodes, segments, chains} = parseInput(text);
      layoutSimple(chains);
      render(nodes, segments);
    });

    function parseInput(text) {
      const nodeMap = new Map();
      const segments = [];
      const chains = [];

      function getNode(id) {
        const key = id.toUpperCase();
        if (!nodeMap.has(key)) {
          nodeMap.set(key, {id: key, x: null, y: null, fixed: false});
        }
        return nodeMap.get(key);
      }

      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);

      lines.forEach((line, lineIndex) => {
        // Simpele parsing: NODE -- NODE [DIST]
        const match = line.match(/([A-Z0-9]+)\s*(--|-gebouw-)\s*([A-Z0-9]+)\s*\[([^\]]+)\]/i);
        if (match) {
          const nodeA = parseNodeToken(match[1], getNode);
          const nodeB = parseNodeToken(match[3], getNode);
          nodeA.chainId = lineIndex;
          nodeB.chainId = lineIndex;

          const dist = parseFloat(match[4].replace(',', '.'));
          const segType = match[2].toLowerCase().includes('gebouw') ? 'gebouw' : 'default';

          segments.push({from: nodeA, to: nodeB, dist, type: segType});
          chains.push({nodes: [nodeA, nodeB], segments: [{from: nodeA, to: nodeB, dist, type: segType}], lineIndex});
        }
      });

      return {nodes: Array.from(nodeMap.values()), segments, chains};
    }

    function parseNodeToken(raw, getNode) {
      const idMatch = raw.match(/^[A-Z0-9]+/i);
      const id = idMatch ? idMatch[0] : raw.trim();
      const node = getNode(id);

      const coordMatch = raw.match(/\(([^\)]+)\)/);
      if (coordMatch) {
        const nums = coordMatch[1].split(',').map(s => parseFloat(s.trim()));
        if (nums.length >= 2 && !isNaN(nums[0]) && !isNaN(nums[1])) {
          node.x = nums[0];
          node.y = nums[1];
          node.fixed = true;
        }
      }
      return node;
    }

    // Eenvoudige layout: elke lijn apart plaatsen in driehoekvorm
    function layoutSimple(chains) {
      chains.forEach((chain, i) => {
        const angle = (i * Math.PI * 2) / 3; // 120 graden tussen lijnen
        const length = chain.segments[0].dist || 10;
        
        chain.nodes[0].x = 0;
        chain.nodes[0].y = 0;
        chain.nodes[1].x = length * Math.cos(angle);
        chain.nodes[1].y = length * Math.sin(angle);
      });
    }

    function render(nodes, segments) {
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const xs = nodes.map(n => n.x).filter(x => x != null);
      const ys = nodes.map(n => n.y).filter(y => y != null);
      let minX = xs.length ? Math.min(...xs) : -10;
      let maxX = xs.length ? Math.max(...xs) : 10;
      let minY = ys.length ? Math.min(...ys) : -10;
      let maxY = ys.length ? Math.max(...ys) : 10;
      
      const pad = 5;
      svg.setAttribute('viewBox', 
        [minX - pad, minY - pad, maxX - minX + 2*pad, maxY - minY + 2*pad].join(' '));

      // Segmenten
      for (const seg of segments) {
        const a = seg.from, b = seg.to;
        if (a.x == null || b.x == null) continue;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        line.setAttribute('class', 'segment ' + 
          (seg.type === 'gebouw' ? 'segment-gebouw' : 'segment-default'));
        svg.appendChild(line);

        if (seg.dist != null) {
          const mx = (a.x + b.x) / 2;
          const my = (a.y + b.y) / 2;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', mx);
          text.setAttribute('y', my - 1);
          text.setAttribute('class', 'distance-label');
          text.textContent = seg.dist.toFixed(2);
          svg.appendChild(text);
        }
      }

      // Punten
      const maxDim = 20;
      const r = 3;
      for (const n of nodes) {
        if (n.x == null || n.y == null) continue;
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', n.x);
        circle.setAttribute('cy', n.y);
        circle.setAttribute('r', r);
        circle.setAttribute('class', 'point');
        svg.appendChild(circle);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', n.x + 1);
        label.setAttribute('y', n.y - 1);
        label.setAttribute('class', 'point-label');
        label.textContent = n.id;
        svg.appendChild(label);
      }
    }

    textarea.dispatchEvent(new Event('input'));
  </script>
</body>
</html>
