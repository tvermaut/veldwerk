<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Kadastrale ketens – rigide rechte lijnen</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: sans-serif; height: 100vh; display: flex; }
    #left { width: 45%; padding: 10px; border-right: 1px solid #ccc; }
    #right { width: 55%; padding: 10px; }
    textarea { width: 100%; height: calc(100vh - 60px); font-family: monospace; font-size: 13px; }
    button { margin-top: 6px; padding: 6px 10px; }
    svg { width: 100%; height: calc(100vh - 20px); border: 1px solid #ccc; background: #fafafa; cursor: grab; }
    .point { fill: #0074D9; stroke: #003366; stroke-width: 0.1; }
    .point-label { font-size: 1.1px; fill: #000; }
    .residual-label { font-size: 1px; fill: #d00; }
    .distance-label { font-size: 1px; fill: #555; }
    .segment { stroke-width: 0.2; }
    .segment-default { stroke: #111; }
    .segment-gebouw { stroke: #d00; }
    .error { color: #b00; margin-top: 6px; white-space: pre-line; }
  </style>
</head>
<body>
  <div id="left">
    <h3>Kadastrale ketens</h3>
    <p>Per regel een rechte keten. Afstand in [ ] is t.o.v. het eerste punt van die keten.</p>
<textarea id="input">
P1 [0] -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
P1 [0] -- P5 [0.40] -gebouw- P6 [10.55] -- P7 [11.80]
P7 [11.80] -- P4 [16.05] [25]</textarea>
    <button id="solveBtn">Herbereken</button>
    <div id="msg" class="error"></div>
  </div>

  <div id="right">
    <svg id="viewBox"></svg>
  </div>

<script>
const textarea = document.getElementById('input');
const svg      = document.getElementById('viewBox');
const solveBtn = document.getElementById('solveBtn');
const msgEl    = document.getElementById('msg');

let currentViewBox = {x: 0, y: 0, w: 100, h: 100};

solveBtn.addEventListener('click', solveAndDraw);
window.addEventListener('load', solveAndDraw);

// pan/zoom state
let isPanning = false;
let panStart = {x: 0, y: 0};
let viewBoxStart = null;

// muis naar SVG-coördinaten
function clientToSvg(evt) {
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
  return {x: svgP.x, y: svgP.y};
}

// pannen
svg.addEventListener('mousedown', evt => {
  isPanning = true;
  svg.style.cursor = 'grabbing';
  panStart = clientToSvg(evt);
  viewBoxStart = {...currentViewBox};
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  svg.style.cursor = 'grab';
});
window.addEventListener('mousemove', evt => {
  if (!isPanning) return;
  const pos = clientToSvg(evt);
  const dx = pos.x - panStart.x;
  const dy = pos.y - panStart.y;
  currentViewBox.x = viewBoxStart.x - dx;
  currentViewBox.y = viewBoxStart.y - dy;
  applyViewBox();
});

// zoomen met muiswiel
svg.addEventListener('wheel', evt => {
  evt.preventDefault();
  const scaleFactor = evt.deltaY < 0 ? 0.9 : 1.1;
  const mouse = clientToSvg(evt);
  const vb = currentViewBox;

  const newW = vb.w * scaleFactor;
  const newH = vb.h * scaleFactor;

  const mx = (mouse.x - vb.x) / vb.w;
  const my = (mouse.y - vb.y) / vb.h;

  currentViewBox.x = mouse.x - mx * newW;
  currentViewBox.y = mouse.y - my * newH;
  currentViewBox.w = newW;
  currentViewBox.h = newH;
  applyViewBox();
}, {passive: false});

function applyViewBox() {
  svg.setAttribute('viewBox',
    `${currentViewBox.x} ${currentViewBox.y} ${currentViewBox.w} ${currentViewBox.h}`);
}

// -------- hoofdentry --------
function solveAndDraw() {
  msgEl.textContent = '';
  let parsed;
  try {
    parsed = parseInput(textarea.value);
  } catch (e) {
    msgEl.textContent = 'Parse-fout: ' + e.message;
    clearSvg();
    return;
  }
  const {lines, links} = parsed;
  if (!lines.length) {
    msgEl.textContent = 'Geen lijnen gevonden.';
    clearSvg();
    return;
  }

  layoutRigidLines(lines, links);
  renderSvg(lines, links);
}

// ------------ parsing ------------

// Ketenregel, voorbeeld:
//   P1 [0] -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
// De waarde in [ ] is de afstand t.o.v. het eerste punt van die regel.
//
// Linkregel (optioneel), voorbeeld:
//   P7 [11.80] -- P4 [16.05] [25]
function parseInput(text) {
  const lines = [];   // {id, points:[{name,t}], x0,y0,theta}
  const links = [];   // {aName, bName, dist}

  const rows = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  rows.forEach((row, idx) => {
    const parts = row.split(/--/).map(p => p.trim()).filter(Boolean);
    const brackets = row.match(/\[[^\]]+\]/g) || [];

    // Keten: aantal [..] >= aantal punten (ieder punt zijn eigen t)
    if (parts.length >= 2 && brackets.length >= parts.length) {
      const line = {id: idx, points: [], x0: 0, y0: 0, theta: 0};
      parts.forEach((tok, i) => {
        const nameMatch = tok.match(/^([A-Za-z]\d+)/);
        if (!nameMatch) throw new Error('Kan puntnaam niet vinden in: ' + tok);
        const name = nameMatch[1].toUpperCase();
        const distMatch = tok.match(/\[([^\]]+)\]/);
        const t = distMatch ? parseFloat(distMatch[1].replace(',', '.')) : (i === 0 ? 0 : NaN);
        if (!isFinite(t)) throw new Error('Ongeldige afstand in: ' + tok);
        line.points.push({name, t});
      });
      lines.push(line);

    // Linkregel: precies twee punten en één extra [afstand] op het eind
    } else if (parts.length === 2 && brackets.length >= 1) {
      const left  = parts[0];
      const right = parts[1];

      const leftNameMatch  = left.match(/^([A-Za-z]\d+)/);
      const rightNameMatch = right.match(/^([A-Za-z]\d+)/);
      if (!leftNameMatch || !rightNameMatch) {
        throw new Error('Onjuiste link-regel: ' + row);
      }

      const aName = leftNameMatch[1].toUpperCase();
      const bName = rightNameMatch[1].toUpperCase();
      const distMatch = row.match(/\[([^\]]+)\]\s*$/);
      if (!distMatch) throw new Error('Geen afstand gevonden in link-regel: ' + row);

      const d = parseFloat(distMatch[1].replace(',', '.'));
      if (!isFinite(d)) throw new Error('Ongeldige link-afstand in: ' + row);

      links.push({aName, bName, dist: d});
    } else {
      throw new Error('Onherkenbare regel: ' + row);
    }
  });

  return {lines, links};
}

// ------------ rigid layout ------------

// Elke regel is een starre rechte: alle punten P_i = p0 + t_i * u.
// Richting u (theta) staat vast per regel; alleen p0 (x0,y0) wordt verschoven
// op basis van link-afstanden. Hierdoor kan een lijn niet knikken.
function layoutRigidLines(lines, links) {
  // initiële richting per lijn
  lines.forEach((ln, i) => {
    ln.x0 = 0;
    ln.y0 = i * 10;      // verticale spreiding
    ln.theta = 0.4 * i;  // vaste verschillende richtingen
  });

  const iters = 300;
  const stepPos = 0.02;

  for (let it = 0; it < iters; it++) {
    const grad = lines.map(() => ({gx0: 0, gy0: 0}));

    links.forEach(link => {
      const aInfo = findPointOnLines(lines, link.aName);
      const bInfo = findPointOnLines(lines, link.bName);
      if (!aInfo || !bInfo) return;

      const la = aInfo.line;
      const lb = bInfo.line;
      const pa = pointFromLine(la, aInfo.point);
      const pb = pointFromLine(lb, bInfo.point);

      const dx = pb.x - pa.x;
      const dy = pb.y - pa.y;
      const dist = Math.hypot(dx, dy) || 1e-6;
      const err = dist - link.dist;

      const k = 1.0;
      const fx = k * err * (dx / dist);
      const fy = k * err * (dy / dist);

      const gA = grad[aInfo.lineIndex];
      const gB = grad[bInfo.lineIndex];

      gA.gx0 +=  fx;
      gA.gy0 +=  fy;
      gB.gx0 -=  fx;
      gB.gy0 -=  fy;
    });

    lines.forEach((ln, i) => {
      ln.x0 -= grad[i].gx0 * stepPos;
      ln.y0 -= grad[i].gy0 * stepPos;
    });
  }
}

function findPointOnLines(lines, name) {
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    for (const p of line.points) {
      if (p.name === name) {
        return { line, lineIndex: i, point: p };
      }
    }
  }
  return null;
}

function pointFromLine(line, point) {
  const ux = Math.cos(line.theta);
  const uy = Math.sin(line.theta);
  return {
    x: line.x0 + point.t * ux,
    y: line.y0 + point.t * uy
  };
}

// ------------ tekenen + residu's ------------

function renderSvg(lines, links) {
  clearSvg();

  const pointCoords = new Map(); // name -> {x,y}
  lines.forEach(line => {
    line.points.forEach(p => {
      const pos = pointFromLine(line, p);
      pointCoords.set(p.name, pos);
    });
  });

  // residu per link op positie/lengte
  const pointResidual = new Map(); // name -> max |dist_err|
  const segResidual = [];          // {x,y,err}

  if (links) {
    links.forEach(link => {
      const a = pointCoords.get(link.aName);
      const b = pointCoords.get(link.bName);
      if (!a || !b) return;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.hypot(dx, dy) || 1e-6;
      const err = dist - link.dist;

      const absErr = Math.abs(err);
      const prevA = pointResidual.get(link.aName) || 0;
      const prevB = pointResidual.get(link.bName) || 0;
      pointResidual.set(link.aName, Math.max(prevA, absErr));
      pointResidual.set(link.bName, Math.max(prevB, absErr));

      segResidual.push({
        x: (a.x + b.x) / 2,
        y: (a.y + b.y) / 2,
        err: err
      });
    });
  }

  const coords = Array.from(pointCoords.values());
  if (!coords.length) return;

  const xs = coords.map(c => c.x);
  const ys = coords.map(c => c.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const pad  = 2;
  const w = maxX - minX || 10;
  const h = maxY - minY || 10;

  // initiale viewBox voor netjes beeld; daarna kan gebruiker pannen/zoomen
  currentViewBox = {
    x: minX - pad,
    y: minY - pad,
    w: w + 2 * pad,
    h: h + 2 * pad
  };
  applyViewBox();

  // segmenten per lijn
  lines.forEach(line => {
    for (let i = 0; i < line.points.length - 1; i++) {
      const pA = line.points[i];
      const pB = line.points[i + 1];
      const a = pointCoords.get(pA.name);
      const b = pointCoords.get(pB.name);
      if (!a || !b) continue;

      const seg = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      seg.setAttribute('x1', a.x);
      seg.setAttribute('y1', a.y);
      seg.setAttribute('x2', b.x);
      seg.setAttribute('y2', b.y);
      seg.setAttribute('class', 'segment segment-default');
      svg.appendChild(seg);
    }
  });

  // residu-tekst bij lijnmiddens
  segResidual.forEach(sr => {
    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    t.setAttribute('x', sr.x);
    t.setAttribute('y', sr.y);
    t.setAttribute('class', 'residual-label');
    t.textContent = `Δd=${sr.err.toFixed(3)}`;
    svg.appendChild(t);
  });

  // punten + labels + residu-tekst
  const maxDim = Math.max(w, h) || 10;
  const r = Math.max(0.1, maxDim / 200);

  pointCoords.forEach((pos, name) => {
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', pos.x);
    c.setAttribute('cy', pos.y);
    c.setAttribute('r', r);
    c.setAttribute('class', 'point');
    svg.appendChild(c);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', pos.x + r * 1.5);
    label.setAttribute('y', pos.y - r * 1.5);
    label.setAttribute('class', 'point-label');
    label.textContent = name;
    svg.appendChild(label);

    const res = pointResidual.get(name) || 0;
    if (res > 0) {
      const rlabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      rlabel.setAttribute('x', pos.x + r * 1.5);
      rlabel.setAttribute('y', pos.y + r * 1.5);
      rlabel.setAttribute('class', 'residual-label');
      rlabel.textContent = `Δ=${res.toFixed(3)}`;
      svg.appendChild(rlabel);
    }
  });
}

function clearSvg() {
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}
</script>
</body>
</html>
