<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Kadastrale metingen visualisatie</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
    }
    #left, #right {
      padding: 10px;
      height: 100vh;
    }
    #left {
      width: 50%;
      border-right: 1px solid #ccc;
    }
    #right {
      width: 50%;
    }
    textarea {
      width: 100%;
      height: calc(100vh - 20px);
      font-family: monospace;
      font-size: 14px;
    }
    svg {
      width: 100%;
      height: 100%;
      border: 1px solid #ccc;
      background: #fafafa;
    }
    .point {
      fill: #0074D9;
      stroke: #003366;
      stroke-width: 1;
    }
    .point-label {
      font-size: 12px;
      fill: #000;
    }
    .distance-label {
      font-size: 11px;
      fill: #555;
    }
    .segment {
      stroke-width: 2;
    }
    .segment-default {
      stroke: #111;
    }
    .segment-gebouw {
      stroke: #d00;
    }
  </style>
</head>
<body>
  <div id="left">
    <textarea id="input"
placeholder="Voorbeelden:
P1(0,0) [0] -- P2(10,0) [10] -- P3(10,5) [15]
P1 -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
P1 -- P5 [0.4] -- P6 [10.55] -- P7 [11.8]
P1 -gebouw- P2 [5.40] -gebouw- P3 [8.83]"></textarea>
  </div>
  <div id="right">
    <svg id="viewBox" viewBox="0 0 100 100"></svg>
  </div>

  <script>
    const textarea = document.getElementById('input');
    const svg = document.getElementById('viewBox');

    textarea.addEventListener('input', () => {
      const text = textarea.value;
      const {nodes, segments} = parseInput(text);
      layoutNodes(nodes, segments);
      render(nodes, segments);
    });

    // --- Parsing ---

    // nodes: {id, x, y, fixed, vx, vy}
    // segments: {from, to, dist, type}  type: 'default' of 'gebouw'
    function parseInput(text) {
      const nodeMap = new Map();
      const segments = [];

      function getNode(id) {
        const key = id.toUpperCase();
        if (!nodeMap.has(key)) {
          nodeMap.set(key, {
            id: key,
            x: null,
            y: null,
            fixed: false,
            vx: 0,
            vy: 0
          });
        }
        return nodeMap.get(key);
      }

      const lines = text.split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length > 0);

      for (const line of lines) {
        // splits op zowel '--' als '-gebouw-'
        const rawParts = line.split(/(-gebouw-)|(--)/i).filter(p => p && p.trim() !== '');
        if (rawParts.length === 0) continue;

        // bouw lijst van: node, connector, node, connector, ...
        const tokens = [];
        for (const part of rawParts) {
          const trimmed = part.trim();
          if (/^-?gebouw-?$/i.test(trimmed)) {
            tokens.push({type: 'connector', value: 'gebouw'});
          } else if (trimmed === '--') {
            tokens.push({type: 'connector', value: 'default'});
          } else {
            tokens.push({type: 'node', value: trimmed});
          }
        }

        // loop: node - connector - node - ...
        for (let i = 0; i < tokens.length - 2; i += 2) {
          const tA = tokens[i];
          const tC = tokens[i + 1];
          const tB = tokens[i + 2];
          if (tA.type !== 'node' || tC.type !== 'connector' || tB.type !== 'node') continue;

          const segType = tC.value === 'gebouw' ? 'gebouw' : 'default';

          // parse node A
          const nodeA = parseNodeToken(tA.value, getNode);
          const nodeB = parseNodeToken(tB.value, getNode);

          // afstand zit in de tweede token (tB)
          const distMatch = tB.value.match(/\[([^\]]+)\]/);
          let dist = null;
          if (distMatch) {
            const d = parseFloat(distMatch[1].trim().replace(',', '.'));
            if (!isNaN(d)) dist = d;
          }

          segments.push({
            from: nodeA,
            to: nodeB,
            dist,
            type: segType
          });
        }
      }

      const nodes = Array.from(nodeMap.values());
      return {nodes, segments};
    }

    function parseNodeToken(raw, getNode) {
      // identifier: tot '(' of '[' of spatie
      const idMatch = raw.match(/^[^\s\(\[]+/);
      const id = idMatch ? idMatch[0] : raw.trim();
      const node = getNode(id);

      // coordinaat
      const coordMatch = raw.match(/\(([^\)]+)\)/);
      if (coordMatch) {
        const nums = coordMatch[1].split(',').map(s => parseFloat(s.trim().replace(',', '.')));
        if (nums.length >= 2 && !isNaN(nums[0]) && !isNaN(nums[1])) {
          node.x = nums[0];
          node.y = nums[1];
          node.fixed = true;
        }
      }
      return node;
    }

    // --- Layout met eenvoudige afstoot + veer op segmenten ---

    function layoutNodes(nodes, segments) {
      if (nodes.length === 0) return;

      // 1. Zet per regel een rechte lijn op basis van afstand
      //    We reconstrueren hier ketens per invoerregel opnieuw.
      const text = textarea.value;
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);

      const used = new Set(); // nodes die al een positie krijgen via een rechte lijn

      for (const line of lines) {
        // hergebruik dezelfde parsing als eerder, maar alleen voor deze lijn
        const {nodes: lineNodes, segments: lineSegs} = parseInput(line);

        if (lineNodes.length === 0) continue;

        // bepaal volgorde langs de lijn uit de segmenten
        // we nemen de eerste segmentketen als volgorde
        const order = [];
        if (lineSegs.length > 0) {
          let current = lineSegs[0].from;
          order.push(current);
          for (const seg of lineSegs) {
            if (seg.from === current && !order.includes(seg.to)) {
              order.push(seg.to);
              current = seg.to;
            }
          }
        } else {
          // geen segmenten (alleen losse punten op de regel)
          order.push(...lineNodes);
        }

        // afstandscumulatie langs de lijn
        const posMap = new Map();
        let cum = 0;
        posMap.set(order[0].id, 0);
        for (let i = 1; i < order.length; i++) {
          const prev = order[i - 1];
          const cur = order[i];
          const seg = lineSegs.find(s =>
            (s.from === prev && s.to === cur) || (s.to === prev && s.from === cur)
          );
          if (seg && seg.dist != null) {
            cum += seg.dist;
          } else {
            cum += 1; // fallback: 1 eenheid als er geen afstand is
          }
          posMap.set(cur.id, cum);
        }

        // schaalfactor voor deze regel
        const idealScale = 5;
        const angle = 0; // allemaal horizontaal; later met rotatie/force t.o.v. andere lijnen
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);

        for (const n of lineNodes) {
          const key = n.id.toUpperCase();
          const master = nodes.find(nn => nn.id === key);
          if (!master) continue;

          const t = (posMap.get(n.id) || 0) * idealScale;
          if (!master.fixed) {
            master.x = t * cosA;
            master.y = t * sinA;
            used.add(master.id);
          }
        }
      }

      // 2. Voor nodes die nog geen positie hebben: cirkel-initialisatie
      const radius = 10;
      let freeNodes = nodes.filter(n => !used.has(n.id) && !n.fixed);
      let angleStep = (2 * Math.PI) / Math.max(1, freeNodes.length);
      freeNodes.forEach((n, i) => {
        n.x = radius * Math.cos(i * angleStep);
        n.y = radius * Math.sin(i * angleStep);
        n.vx = 0;
        n.vy = 0;
      });

      // 3. Korte relaxatie met afstoot + veer op segmenten (zoals eerder),
      //    maar met minder iteraties zodat de rechte lijnen grotendeels recht blijven.
      const iterations = 60;
      const repulsion = 50;
      const springK = 0.5;
      const idealScale = 5;
      const damping = 0.85;

      for (let it = 0; it < iterations; it++) {
        for (const n of nodes) {
          if (!n.fixed) {
            n.vx *= damping;
            n.vy *= damping;
          }
        }

        // afstoot
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            let dx = a.x - b.x;
            let dy = a.y - b.y;
            let dist2 = dx * dx + dy * dy + 0.01;
            let dist = Math.sqrt(dist2);
            let force = repulsion / dist2;
            dx /= dist;
            dy /= dist;
            if (!a.fixed) { a.vx += dx * force; a.vy += dy * force; }
            if (!b.fixed) { b.vx -= dx * force; b.vy -= dy * force; }
          }
        }

        // veren
        for (const seg of segments) {
          const a = seg.from;
          const b = seg.to;
          if (a.x == null || b.x == null) continue;
          const target = seg.dist != null ? seg.dist * idealScale : null;
          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
          dx /= dist;
          dy /= dist;
          let desired = target || dist;
          let delta = dist - desired;
          let force = springK * delta;
          if (!a.fixed) { a.vx += dx * force; a.vy += dy * force; }
          if (!b.fixed) { b.vx -= dx * force; b.vy -= dy * force; }
        }

        for (const n of nodes) {
          if (n.fixed) continue;
          n.x += n.vx * 0.1;
          n.y += n.vy * 0.1;
        }
      }
    }

    // --- Tekenfunctie ---

    function render(nodes, segments) {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      if (nodes.length === 0) return;

      const xs = nodes.map(n => n.x);
      const ys = nodes.map(n => n.y);
      let minX = Math.min(...xs), maxX = Math.max(...xs);
      let minY = Math.min(...ys), maxY = Math.max(...ys);
      if (minX === maxX) { minX -= 1; maxX += 1; }
      if (minY === maxY) { minY -= 1; maxY += 1; }
      const pad = 5;
      const width = maxX - minX;
      const height = maxY - minY;

      svg.setAttribute('viewBox',
        [minX - pad, minY - pad, width + 2 * pad, height + 2 * pad].join(' '));

      // segmenten
      for (const seg of segments) {
        const a = seg.from, b = seg.to;
        if (a.x == null || b.x == null) continue;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        line.setAttribute('class', 'segment ' +
          (seg.type === 'gebouw' ? 'segment-gebouw' : 'segment-default'));
        svg.appendChild(line);

        if (seg.dist != null) {
          const mx = (a.x + b.x) / 2;
          const my = (a.y + b.y) / 2;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', mx);
          text.setAttribute('y', my - 1);
          text.setAttribute('class', 'distance-label');
          text.textContent = seg.dist;
          svg.appendChild(text);
        }
      }

      // punten
      const maxDim = Math.max(width, height) || 1;
      const r = 0.6 * maxDim / 50;
      for (const n of nodes) {
        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        c.setAttribute('cx', n.x);
        c.setAttribute('cy', n.y);
        c.setAttribute('r', r);
        c.setAttribute('class', 'point');
        svg.appendChild(c);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', n.x + maxDim / 100);
        label.setAttribute('y', n.y - maxDim / 100);
        label.setAttribute('class', 'point-label');
        label.textContent = n.id;
        svg.appendChild(label);
      }
    }

    // init met voorbeeld
    textarea.value =
`P1 -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
P1 -- P5 [0.4] -- P6 [10.55] -- P7 [11.8]
P1 -gebouw- P2 [5.40] -gebouw- P3 [8.83]`;
    textarea.dispatchEvent(new Event('input'));
  </script>
</body>
</html>
