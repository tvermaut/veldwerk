<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Kadastrale ketens – rigide rechte lijnen</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: sans-serif; height: 100vh; display: flex; }
    #left { width: 45%; padding: 10px; border-right: 1px solid #ccc; }
    #right { width: 55%; padding: 10px; }
    textarea { width: 100%; height: calc(100vh - 60px); font-family: monospace; font-size: 13px; }
    button { margin-top: 6px; padding: 6px 10px; }
    svg { width: 100%; height: calc(100vh - 20px); border: 1px solid #ccc; background: #fafafa; }
    .point { fill: #0074D9; stroke: #003366; stroke-width: 1; }
    .point-label { font-size: 11px; fill: #000; }
    .distance-label { font-size: 10px; fill: #555; }
    .segment { stroke-width: 2; }
    .segment-default { stroke: #111; }
    .segment-gebouw { stroke: #d00; }
    .error { color: #b00; margin-top: 6px; white-space: pre-line; }
  </style>
</head>
<body>
  <div id="left">
    <h3>Kadastrale ketens</h3>
    <p>Per regel een rechte keten. Afstand in [ ] is t.o.v. het eerste punt van die keten.</p>
<textarea id="input">
P1 [0] -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
P1 [0] -- P5 [0.40] -gebouw- P6 [10.55] -- P7 [11.80]
P7 [11.80] -- P4 [16.05] [25]</textarea>
    <button id="solveBtn">Herbereken</button>
    <div id="msg" class="error"></div>
  </div>

  <div id="right">
    <svg id="viewBox"></svg>
  </div>

<script>
const textarea = document.getElementById('input');
const svg      = document.getElementById('viewBox');
const solveBtn = document.getElementById('solveBtn');
const msgEl    = document.getElementById('msg');

solveBtn.addEventListener('click', solveAndDraw);
window.addEventListener('load', solveAndDraw);

// ------------ hoofdentry ------------
function solveAndDraw() {
  msgEl.textContent = '';
  let parsed;
  try {
    parsed = parseInput(textarea.value);
  } catch (e) {
    msgEl.textContent = 'Parse-fout: ' + e.message;
    clearSvg();
    return;
  }
  const {lines, links} = parsed;
  if (!lines.length) {
    msgEl.textContent = 'Geen lijnen gevonden.';
    clearSvg();
    return;
  }

  layoutRigidLines(lines, links);
  renderSvg(lines);
}

// ------------ parsing ------------

// Ketenregel, voorbeeld:
//   P1 [0] -- P2 [5.40] -- P3 [8.83] -- P4 [16.05]
// De waarde in [ ] is de afstand t.o.v. het eerste punt van die regel.
//
// Linkregel (optioneel), voorbeeld:
//   P7 [11.80] -- P4 [16.05] [25]
// waarbij het laatste [25] de gemeten afstand tussen P7 en P4 is.
function parseInput(text) {
  const lines = [];   // {id, points:[{name,t}], x0,y0,theta}
  const links = [];   // {aName, bName, dist}

  const rows = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  rows.forEach((row, idx) => {
    const parts = row.split(/--/).map(p => p.trim()).filter(Boolean);
    const brackets = row.match(/\[[^\]]+\]/g) || [];

    // Keten: aantal [..] >= aantal punten (ieder punt zijn eigen t)
    if (parts.length >= 2 && brackets.length >= parts.length) {
      const line = {id: idx, points: [], x0: 0, y0: 0, theta: 0};
      parts.forEach((tok, i) => {
        const nameMatch = tok.match(/^([A-Za-z]\d+)/);
        if (!nameMatch) throw new Error('Kan puntnaam niet vinden in: ' + tok);
        const name = nameMatch[1].toUpperCase();
        const distMatch = tok.match(/\[([^\]]+)\]/);
        const t = distMatch ? parseFloat(distMatch[1].replace(',', '.')) : (i === 0 ? 0 : NaN);
        if (!isFinite(t)) throw new Error('Ongeldige afstand in: ' + tok);
        line.points.push({name, t});
      });
      lines.push(line);

    // Linkregel: precies twee punten en één extra [afstand] op het eind
    } else if (parts.length === 2 && brackets.length >= 1) {
      const left  = parts[0];
      const right = parts[1];

      const leftNameMatch  = left.match(/^([A-Za-z]\d+)/);
      const rightNameMatch = right.match(/^([A-Za-z]\d+)/);
      if (!leftNameMatch || !rightNameMatch) {
        throw new Error('Onjuiste link-regel: ' + row);
      }

      const aName = leftNameMatch[1].toUpperCase();
      const bName = rightNameMatch[1].toUpperCase();
      const distMatch = row.match(/\[([^\]]+)\]\s*$/);
      if (!distMatch) throw new Error('Geen afstand gevonden in link-regel: ' + row);

      const d = parseFloat(distMatch[1].replace(',', '.'));
      if (!isFinite(d)) throw new Error('Ongeldige link-afstand in: ' + row);

      links.push({aName, bName, dist: d});
    } else {
      throw new Error('Onherkenbare regel: ' + row);
    }
  });

  return {lines, links};
}

// ------------ rigid layout ------------

// Elke regel is een starre rechte: alle punten P_i = p0 + t_i * u.
// Richting u (theta) staat vast per regel; alleen p0 (x0,y0) wordt verschoven
// op basis van link-afstanden. Daardoor kan een lijn nooit knikken.
function layoutRigidLines(lines, links) {
  // initiële richting per lijn
  lines.forEach((ln, i) => {
    ln.x0 = 0;
    ln.y0 = i * 10;      // verticale spreiding
    ln.theta = 0.4 * i;  // vaste verschillende richtingen
  });

  // eenvoudige iteratieve verschuiving op basis van link-afstanden
  const iters = 300;
  const stepPos = 0.02;

  for (let it = 0; it < iters; it++) {
    const grad = lines.map(() => ({gx0: 0, gy0: 0}));

    links.forEach(link => {
      const aInfo = findPointOnLines(lines, link.aName);
      const bInfo = findPointOnLines(lines, link.bName);
      if (!aInfo || !bInfo) return;

      const la = aInfo.line;
      const lb = bInfo.line;
      const pa = pointFromLine(la, aInfo.point);
      const pb = pointFromLine(lb, bInfo.point);

      const dx = pb.x - pa.x;
      const dy = pb.y - pa.y;
      const dist = Math.hypot(dx, dy) || 1e-6;
      const err = dist - link.dist;

      const k = 1.0;
      const fx = k * err * (dx / dist);
      const fy = k * err * (dy / dist);

      const gA = grad[aInfo.lineIndex];
      const gB = grad[bInfo.lineIndex];

      // alleen translatie van lijnen; geen rotatie
      gA.gx0 +=  fx;
      gA.gy0 +=  fy;
      gB.gx0 -=  fx;
      gB.gy0 -=  fy;
    });

    // update oorsprongen
    lines.forEach((ln, i) => {
      ln.x0 -= grad[i].gx0 * stepPos;
      ln.y0 -= grad[i].gy0 * stepPos;
    });
  }
}

function findPointOnLines(lines, name) {
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    for (const p of line.points) {
      if (p.name === name) {
        return { line, lineIndex: i, point: p };
      }
    }
  }
  return null;
}

function pointFromLine(line, point) {
  const ux = Math.cos(line.theta);
  const uy = Math.sin(line.theta);
  return {
    x: line.x0 + point.t * ux,
    y: line.y0 + point.t * uy
  };
}

// ------------ tekenen ------------

function renderSvg(lines) {
  clearSvg();

  const pointCoords = new Map(); // name -> {x,y}
  lines.forEach(line => {
    line.points.forEach(p => {
      const pos = pointFromLine(line, p);
      pointCoords.set(p.name, pos);
    });
  });

  const coords = Array.from(pointCoords.values());
  if (!coords.length) return;

  const xs = coords.map(c => c.x);
  const ys = coords.map(c => c.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const pad  = 2;
  const w = maxX - minX || 10;
  const h = maxY - minY || 10;
  svg.setAttribute('viewBox',
    `${minX - pad} ${minY - pad} ${w + 2 * pad} ${h + 2 * pad}`);

  // segmenten per lijn
  lines.forEach(line => {
    for (let i = 0; i < line.points.length - 1; i++) {
      const pA = line.points[i];
      const pB = line.points[i + 1];
      const a = pointCoords.get(pA.name);
      const b = pointCoords.get(pB.name);
      if (!a || !b) continue;

      const seg = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      seg.setAttribute('x1', a.x);
      seg.setAttribute('y1', a.y);
      seg.setAttribute('x2', b.x);
      seg.setAttribute('y2', b.y);
      seg.setAttribute('class', 'segment segment-default');
      svg.appendChild(seg);
    }
  });

  // punten + labels
  const maxDim = Math.max(w, h) || 10;
  const r = Math.max(0.3, maxDim / 80);

  pointCoords.forEach((pos, name) => {
    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    c.setAttribute('cx', pos.x);
    c.setAttribute('cy', pos.y);
    c.setAttribute('r', r);
    c.setAttribute('class', 'point');
    svg.appendChild(c);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', pos.x + r * 1.5);
    label.setAttribute('y', pos.y - r * 1.5);
    label.setAttribute('class', 'point-label');
    label.textContent = name;
    svg.appendChild(label);
  });
}

function clearSvg() {
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}
</script>
</body>
</html>
